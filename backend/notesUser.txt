User Side

✔ Search any product
✔ Shows closest stores with availability
✔ Shows map path and walking/driving distance
✔ Shows store pricing & stock
   Option to pre-book


User Search
   ↓
Search API
   ↓
Geo Query (Mongo)
   ↓
Product Filter
   ↓
Store List (sorted)
   ↓
Map + Route
   ↓
Search Log Saved
   ↓
Vendor Demand Dashboard

“I need a product → show me nearest store → cheapest/fastest → route → done”
{{Google Maps + Amazon search combined}}

Documentation:

1. User Auth:
   Register -> Verify OTP -> Login
   using jwt token and cookies

2. Search Functionality (Product Search):
   MongoDB Atlas Search Index Inplemented -> Like Nearest Vendor -> Having product 
   Using Redis Cache
   with cacheInvalidation for UpdateProduct and DeleteProduct Controllers for vendor portal crud

3. Zustand for managing client-side state:
      why need ? Same data fetched multiple times
                 page State dies on navigation
                 currently there's no global truth 
      State management = a single, predictable source of truth for your app’s client-side data

   state =
      search query
      user location
      nearby stores
      selected store
      intent (viewing, navigating, booking)
      auth user/vendor

      Redux	is Too heavy, boilerplate
      Context API	is Re-renders entire tree
      URL state only	is Limited, messy
      ✅**Zustand** is Minimal, fast, scalable
   
   Axios file = “How to talk to backend”
   Zustand store = “What data does the app currently believe is true”
   --They work together

   We added Zustand stores that:
      Call API helpers
      Store the response globally
      Let ANY component read it
      Persist important state if needed

      *Key Changes-*
      Aspect	         Before	After
      useState Hooks	   7	      0
      useEffect Hooks	3	      1
      setState Calls	   6+	      1
      Code Lines	      ~140	   ~90
      Breaking Changes	N/A	   0

4. Events Driven Trigers Required in User Module:

      User Action
         ↓
      UserIntent API
         ↓  userIntentModel with three (intent types & statuses)
         ↓  and a notification model with User ref and title, message, link, Read
      Stored as ACTIVE intent (in starting on reserving/enabling notify)  ->   which later updates to triggered on updation/notify
         ↓
      Vendor updates product
         ↓
      Intent Processor runs (utils)
         ↓
      Notification created
         ↓
      User sees it in MyInVolv
   
   1. UserIntent & Notification Model 
   2. Then create , cancel, getMy( id params) - Intent controller 
      & getNotification , markasread (id params), unreadCount - notification controller
   3. Then making routes for these 2*(3) api's
   4. INTENT Processor for what to trigger with what content  -  processProductIntent & trigger
   5. Then Connect this processor to existing product exist api
   6. Complete User Flow:
            User
               ✔ Clicks Reserve / Notify
               ✔ Intent saved
            Vendor
               ✔ Updates product
            Backend
               ✔ Intent processor runs
               ✔ Notification created
            User
               ✔ Sees badge in navbar
               ✔ Opens MyInVolv
               ✔ Marks read / cancels
   7.